import random
from copy import deepcopy
from level import Level
from global_vars import *

DIRECTIONS = ((0, -1), (0, 1), (-1, 0), (1, 0))

class Monte_carlo_level(Level):
	"""Level generated by a Monate-Carlo Player"""
	def __init__(self, diff):
		assert 0 < diff < 11 , "difficulty not valid"
		self.difficulty = diff
		self.matrix = load_level("template1.txt")
		self.height = len(self.matrix)
		self.width = len(self.matrix[0])
		self.start = list(self.find_block(START))
		self.goal = list(self.find_block(GOAL))
		self.generate_level()

	def generate_level(self):
		blocks_changed = 0
		max_tries = 11 - self.difficulty #maximum succesful attempts for the level allowed
		number_of_tests = 10
		matrix_copy = deepcopy(self.matrix) # for resetting

		while True:
			if blocks_changed < 20: # start by changing 20 random blocks
				if self.place_rand_block():
					blocks_changed += 1
			elif blocks_changed < 50: 
			#enough blocks have been changed, but not too many. start testing
				succesful_tries = 0
				tests = 0
				while tests <= number_of_tests and succesful_tries <= max_tries: # test level ten times
					if self.test_level():
						succesful_tries += 1 
					tests += 1
				if 0 < succesful_tries <= max_tries:
					# level is solveable and hard enough
					break
				else:
					# level is probably unsolveable, change more blocks
					for dummy in range(5):
						if self.place_rand_block():
							blocks_changed += 1
			else: # reset level to avoid to many changed blocks
				self.matrix = deepcopy(matrix_copy)
				blocks_changed = 0

	def place_rand_block(self):
		"""places random block at random position"""
		rand_x = random.randrange(1, self.width - 1)
		rand_y = random.randrange(1, self.height - 1)
		if self.matrix[rand_y][rand_x] < 3: # changed block shouldn't be a start or goal block
			self.matrix[rand_y][rand_x] = random.randrange(3)
			return True

	def test_level(self):
		"""tests level by letting a virtual character make 200 random moves in it"""
		pos = list(self.start)
		for dummy in range(200): 
			movement = self.move(pos, random.choice(DIRECTIONS))
			pos[0] += movement[0]
			pos[1] += movement[1]
			if pos == self.goal:
				return True
		return False

class Custom_level(Level):
	"""different approch to generating a level"""
	def __init__(self):
		self.matrix = load_level("template2.txt")
		self.height = len(self.matrix)
		self.width = len(self.matrix[0])
		#generate start point:
		self.start = [random.randrange(2, self.width - 2), random.randrange(2, self.height - 2)]
		self.matrix[self.start[1]][self.start[0]] = START
		self.main_path = [self.start] # stores stops of the win-path
		self.stones_pos = []
		self.stones = [False] # stores which pos of main-path is a stone
		self.generate_path()
		self.goal = self.main_path[-1]
		self.matrix[self.goal[1]][self.goal[0]] = GOAL
		self.blocks_passed = []


	def generate_path(self, max_lenght = 10):
		"""generates a long path starting from the given start points into an empty template"""	
		all_poss = self.gen_all_poss()
		while all_poss and len(self.main_path) < max_lenght:
			next_stop = random.choice(all_poss)
			if random.random() > 0.5: #50% chance to get a stone-block
				direction = self.find_direction(self.main_path[-1], next_stop)
				next_stop = [direction[1] + next_stop[1], direction[0] + next_stop[0]]
				self.matrix[next_stop[1]][next_stop[0]] = STONE
				self.stones.append(True)
				self.stones_pos.append(next_stop)
			else:
				self.matrix[next_stop[1]][next_stop[0]] = FLOOR
				self.stones.append(False)
			self.main_path.append(next_stop)
			print (self.main_path)
			all_poss = self.gen_all_poss()

	def gen_all_poss(self):
		last = self.main_path[-1]
		all_poss = [[x, last[1]] for x in range(2, self.width - 2)]\
					+ [[last[0], y] for y in range(2, self.height - 2)]

		tabu_blocks = []
		if self.stones[-1]: 
			direction = self.find_direction(self.main_path[-2], self.main_path[-1])
			all_poss = self.filter_blocks_in(all_poss, direction)

		# filter possibilities:
		all_poss = [pos 
				for pos in all_poss
				if self.connected_main_path(pos, self.stones[-1])
				and pos not in self.main_path
				and self.matrix[pos[1]][pos[0]] == ICE
				and not self.connected_stones(pos)
			]
		if len(self.main_path) > 1:
			all_poss = self.filter_blocks_in(all_poss, \
				self.find_direction(self.main_path[-1], self.main_path[-2]))
		print ("also:", all_poss)

		return all_poss

	def filter_blocks_in(self, all_poss, direction):
		tabu_list = []
		last = list(self.main_path[-1])
		while last[0] in range(2, self.width - 2) \
		  and last[1] in range(2, self.height - 2):
			last[0] += direction[0]
			last[1] += direction[1]
			tabu_list.append(list(last))
		print ("---", tabu_list)
		print ("____", all_poss)
		return [pos for pos in all_poss if pos not in tabu_list]
		
	def connected_stones(self, pos):
		for block in self.stones_pos:
			if block[0] == pos[0] or block[1] == pos[1]:
				return True
		return False

	def connected_main_path (self, pos, stone):
		"""checks if block is connected to a block of the win-path"""
		connections = 0
		for direction in DIRECTIONS:
			movement = self.move(pos, direction)
			if [movement[0] + pos[0], movement[1] + pos[1]] in self.main_path:
				connections += 1
		return (connections == 1 and not stone) or (connections == 0 and stone)

	def get_boarder_block(self, block, direction):
		"""returns block at the boarder when only moving in given direction"""
		while block[0] in range(2, self.width - 2) \
		and block[1] in range(2, self.height - 2):
			block[0] += direction[0]
			block[1] += direction[1]
		return block

def load_level(level_file):
	"""takes level file, returns game Matrix"""
	matrix = []
	with open(level_file) as file:
		for line in file:
			matrix.append([int(block) for block in line.split()])
	return matrix

def save_level(matrix, filename):
	"""writes game-matrix in file"""
	with open(filename, "w") as file:
		for line in matrix:
			for block in line:
				file.write(str(block) + " ")
			file.write("\n")